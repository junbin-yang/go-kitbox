package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"reflect"
	"text/template"

	"github.com/junbin-yang/go-kitbox/pkg/binpack"
)

// Generate 生成静态编解码代码
func Generate(typ reflect.Type, pkgName string) ([]byte, error) {
	if typ.Kind() == reflect.Ptr {
		typ = typ.Elem()
	}
	if typ.Kind() != reflect.Struct {
		return nil, fmt.Errorf("type must be struct")
	}

	fields, totalSize, err := analyzeStruct(typ)
	if err != nil {
		return nil, err
	}

	data := templateData{
		Package:   pkgName,
		TypeName:  typ.Name(),
		TotalSize: totalSize,
		Fields:    fields,
	}

	tmpl := template.Must(template.New("codec").Funcs(template.FuncMap{
		"add": func(a, b int) int { return a + b },
	}).Parse(codecTemplate))
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return nil, err
	}

	return format.Source(buf.Bytes())
}

type templateData struct {
	Package   string
	TypeName  string
	TotalSize int
	Fields    []fieldInfo
}

// FieldInfo 字段信息（导出供 CLI 使用）
type FieldInfo struct {
	Name      string
	Type      string
	Offset    int
	Size      int
	ByteOrder string
	IsVar     bool
	LenField  string
}

type fieldInfo = FieldInfo

func analyzeStruct(typ reflect.Type) ([]fieldInfo, int, error) {
	var fields []fieldInfo
	maxSize := 0

	for i := 0; i < typ.NumField(); i++ {
		field := typ.Field(i)
		tag := field.Tag.Get("bin")
		if tag == "" || tag == "-" {
			continue
		}

		info, err := binpack.ParseTag(tag)
		if err != nil {
			return nil, 0, err
		}

		fi := fieldInfo{
			Name:   field.Name,
			Type:   field.Type.String(),
			Offset: info.Offset,
			Size:   info.Size,
		}

		if info.ByteOrder == "le" {
			fi.ByteOrder = "binary.LittleEndian"
		} else {
			fi.ByteOrder = "binary.BigEndian"
		}

		if info.Size == -1 {
			fi.IsVar = true
			fi.LenField = info.LenField
		}

		fields = append(fields, fi)
		if !fi.IsVar && info.Offset+info.Size > maxSize {
			maxSize = info.Offset + info.Size
		}
	}

	return fields, maxSize, nil
}

// ParseTagForGen 解析 tag（供 CLI 使用）
func ParseTagForGen(tag string) (*binpack.TagInfo, error) {
	return binpack.ParseTag(tag)
}

// GenerateFromFields 从字段信息生成代码（供 CLI 使用）
func GenerateFromFields(typeName, pkgName string, fields []FieldInfo, totalSize int) ([]byte, error) {
	data := templateData{
		Package:   pkgName,
		TypeName:  typeName,
		TotalSize: totalSize,
		Fields:    fields,
	}

	tmpl := template.Must(template.New("codec").Funcs(template.FuncMap{
		"add": func(a, b int) int { return a + b },
	}).Parse(codecTemplate))
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return nil, err
	}

	raw := buf.Bytes()
	formatted, err := format.Source(raw)
	if err != nil {
		return nil, fmt.Errorf("%w\nRaw code:\n%s", err, string(raw))
	}
	return formatted, nil
}

const codecTemplate = `// Code generated by binpack-gen. DO NOT EDIT.

package {{.Package}}

import "encoding/binary"

// Marshal{{.TypeName}} 编码 {{.TypeName}}
func Marshal{{.TypeName}}(v *{{.TypeName}}) ([]byte, error) {
	buf := make([]byte, {{.TotalSize}})
	{{range .Fields}}{{if .IsVar}}
	// 变长字段: {{.Name}}
	copy(buf[{{.Offset}}:], v.{{.Name}})
	{{else}}{{if eq .Type "uint8"}}
	buf[{{.Offset}}] = v.{{.Name}}
	{{else if eq .Type "uint16"}}
	{{.ByteOrder}}.PutUint16(buf[{{.Offset}}:], v.{{.Name}})
	{{else if eq .Type "uint32"}}
	{{.ByteOrder}}.PutUint32(buf[{{.Offset}}:], v.{{.Name}})
	{{else if eq .Type "uint64"}}
	{{.ByteOrder}}.PutUint64(buf[{{.Offset}}:], v.{{.Name}})
	{{else if eq .Type "int8"}}
	buf[{{.Offset}}] = uint8(v.{{.Name}})
	{{else if eq .Type "int16"}}
	{{.ByteOrder}}.PutUint16(buf[{{.Offset}}:], uint16(v.{{.Name}}))
	{{else if eq .Type "int32"}}
	{{.ByteOrder}}.PutUint32(buf[{{.Offset}}:], uint32(v.{{.Name}}))
	{{else if eq .Type "int64"}}
	{{.ByteOrder}}.PutUint64(buf[{{.Offset}}:], uint64(v.{{.Name}}))
	{{end}}{{end}}{{end}}
	return buf, nil
}

// Unmarshal{{.TypeName}} 解码 {{.TypeName}}
func Unmarshal{{.TypeName}}(data []byte, v *{{.TypeName}}) error {
	{{range .Fields}}{{if .IsVar}}
	// 变长字段: {{.Name}}
	v.{{.Name}} = make([]byte, v.{{.LenField}})
	copy(v.{{.Name}}, data[{{.Offset}}:])
	{{else}}{{if eq .Type "uint8"}}
	v.{{.Name}} = data[{{.Offset}}]
	{{else if eq .Type "uint16"}}
	v.{{.Name}} = {{.ByteOrder}}.Uint16(data[{{.Offset}}:])
	{{else if eq .Type "uint32"}}
	v.{{.Name}} = {{.ByteOrder}}.Uint32(data[{{.Offset}}:])
	{{else if eq .Type "uint64"}}
	v.{{.Name}} = {{.ByteOrder}}.Uint64(data[{{.Offset}}:])
	{{else if eq .Type "int8"}}
	v.{{.Name}} = int8(data[{{.Offset}}])
	{{else if eq .Type "int16"}}
	v.{{.Name}} = int16({{.ByteOrder}}.Uint16(data[{{.Offset}}:]))
	{{else if eq .Type "int32"}}
	v.{{.Name}} = int32({{.ByteOrder}}.Uint32(data[{{.Offset}}:]))
	{{else if eq .Type "int64"}}
	v.{{.Name}} = int64({{.ByteOrder}}.Uint64(data[{{.Offset}}:]))
	{{end}}{{end}}{{end}}
	return nil
}
`
